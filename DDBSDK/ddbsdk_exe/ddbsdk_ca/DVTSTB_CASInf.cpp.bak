
#include <stdio.h>
#include <winerror.h>
//#include "../wince500/pkfuncs.h"
#include <windows.h>
#include <winioctl.h>

#include "DVTSTB_CASInf.h"
#include "CA_STB_decode.h"
#include "../src/ddbsdk.h"

extern ddbsdk_t  ddbsdk;

extern "C" BOOL KernelIoControl(DWORD dwIoControlCode, LPVOID lpInBuf, DWORD nInBufSize, LPVOID lpOutBuf, DWORD nOutBufSize, LPDWORD lpBytesReturned);
#define IOCTL_HAL_GET_UUID   CTL_CODE(FILE_DEVICE_HAL, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FOR_CAS_DATA_BUFFER_SIZE	64*1024			//终端Flash，用于保存信息，掉电需要保存


extern ShowCAPromptMessage CAshowMessage;
extern errorMessageOccur(int);

//extern ddbsdk_dmbdataInfo_t    dataInfoList;
extern unsigned short getDataECM(u16 pid);

BYTE *  g_BufferForCAS;
//BYTE    g_bDDBHaveCW = 0;
//BYTE	g_OddCW[16];	//存储奇CW
//BYTE	g_EvenCW[16];	//存储偶CW

WORD	g_wCurrentEcmPid = 0;
WORD	g_wTrafficEcmPid = 4112;
WORD	g_wWeatherEcmPid = 4113;
WORD	g_wFinanceEcmPid = 4114;
WORD	g_wPOIinfoEcmPid = 4116;
WORD	g_wSerFileEcmPid = 4117;//WORD	g_wSerFileEcmPid = 4117;
WORD	g_wCarParkEcmPid = 0;
WORD	g_wWeatherFileEcmPid = 0;
WORD	g_wRoadConditionEcmPid = 0;
WORD	g_wEmergencyBroadcastEcmPid = 0;

void InitialDataECMPid(void);
BOOL isInitialDataECMPid = 0;


BYTE	g_TrafficOddCW[16];	
BYTE	g_TrafficEvenCW[16];

BYTE	g_FinanceOddCW[16];	
BYTE	g_FinanceEvenCW[16];

BYTE	g_POIinfoOddCW[16];	
BYTE	g_POIinfoEvenCW[16];
	
BYTE	g_WeatherOddCW[16];	
BYTE	g_WeatherEvenCW[16];

BYTE	g_SerFileOddCW[16];	
BYTE	g_SerFileEvenCW[16];

BYTE	g_CarParkOddCW[16];	
BYTE	g_CarParkEvenCW[16];

BYTE	g_WeatherFileOddCW[16];	
BYTE	g_WeatherFileEvenCW[16];

BYTE	g_RoadConditionOddCW[16];	
BYTE	g_RoadConditionEvenCW[16];

BYTE	g_EmergencyBroadcastOddCW[16];	
BYTE	g_EmergencyBroadcastEvenCW[16];


bool	g_bTrafficHaveCW = false;
bool	g_bWeatherHaveCW = false;
bool	g_bFinanceHaveCW = false;
bool	g_bPOIinfoHaveCW = false;
bool	g_bSerFileHaveCW = false;
bool	g_bCarParkHaveCW = false;
bool	g_bWeatherFileHaveCW = false;
bool	g_bRoadConditionHaveCW = false;
bool	g_bEmergencyBroadcastHaveCW = false;


char*	CAPromptMessage_Traffic = NULL;
char*	CAPromptMessage_Weather = NULL;
char*	CAPromptMessage_Finance = NULL;
char*	CAPromptMessage_POIinfo = NULL;
char*	CAPromptMessage_DowFile = NULL;
char*	CAPromptMessage_CarPark = NULL;
char*	CAPromptMessage_WeatherFile = NULL;
char*	CAPromptMessage_RoadCondition = NULL;
char*	CAPromptMessage_EmergencyBroadcast = NULL;


#if 0
HRESULT DVTSTBCA_GetUUid(BYTE *pbyUUid, unsigned short *pwLen)
{
	char szUUID[16];
	memset(szUUID, 0 , 16);
	memcpy(pbyUUid, szUUID, 16);
	return 0;
}
#else
HRESULT DVTSTBCA_GetUUid(BYTE *pbyUUid, unsigned short *pwLen)
{
#if 0
//	char szUUID[16] = {0xa8, 0x25, 0x0b, 0x81, 0x4c, 0xf4, 0x49, 0x89,
//		0x97, 0x49, 0x42, 0xae, 0xf3, 0x16, 0xb3, 0xf3};
	char szUUID[16] = {0xC1, 0xB1, 0xC6, 0x49, 0x58, 0xA8, 0xEA, 0x0C, 0x92, 0x64, 0xB4, 0x75, 0x77, 0x6A, 0x9E, 0x9A};
	memcpy(pbyUUid, szUUID, 16);
	return 0;
#endif

#if 1
	GUID myUUID;
	BOOL bRetVal;
	DWORD dwBytesReturned;
	bRetVal = KernelIoControl (IOCTL_HAL_GET_UUID, NULL, 0, &myUUID, 
                             sizeof (myUUID), &dwBytesReturned);
	memcpy(pbyUUid, &myUUID, dwBytesReturned);
	printf("%x %x %x %x %x %x %x %x\n", pbyUUid[0], pbyUUid[1], pbyUUid[2], pbyUUid[3], pbyUUid[4], pbyUUid[5], pbyUUid[6], pbyUUid[7]);
	printf("%x %x %x %x %x %x %x %x\n", pbyUUid[8], pbyUUid[9], pbyUUid[10], pbyUUid[11], pbyUUid[12], pbyUUid[13], pbyUUid[14], pbyUUid[15]);

	return 0;
#endif

}
#endif
/*++
功能：获得终端分配给CAS的flash空间的起点地址和大小（以字节为单位）。
参数：
	ppStartAddr:			机顶盒分配给CAS的flash空间的开始地址。
	lSize:					输出机顶盒分配给CAS的flash空间的大小。
--*/
HRESULT DVTSTBCA_GetDataBufferAddr(long* lSize,char ** ppStartAddr)
{
	HRESULT result = 0;
	*lSize = FOR_CAS_DATA_BUFFER_SIZE;
	*ppStartAddr = (char*)g_BufferForCAS;
	return result;
}

/*++
功能：读取保存在终端flash中的信息。
参数：
	pStartAddr:				要读取的存储空间的开始地址。
	plDataLen:				输入为要读取的最长数据值；输出为实际读取的大小。
	pData:					存放输出数据。
--*/
HRESULT DVTSTBCA_ReadDataBuffer(const char * pStartAddr,long * plDataLen,unsigned char* pData)
{
	HRESULT result = 0;
	if(*plDataLen<0)
		return S_FALSE;
	if((DWORD)pStartAddr < (DWORD)g_BufferForCAS 
	|| (DWORD)pStartAddr >= (DWORD)g_BufferForCAS + FOR_CAS_DATA_BUFFER_SIZE)
	{
		return -1;
	}
	if((DWORD)pStartAddr + (*plDataLen) - (DWORD)g_BufferForCAS > FOR_CAS_DATA_BUFFER_SIZE)
	{
		*plDataLen = FOR_CAS_DATA_BUFFER_SIZE - ((DWORD)pStartAddr - (DWORD)g_BufferForCAS);
	}
	try
	{
		memcpy(pData,pStartAddr,*plDataLen);
	}
	catch(...)
	{
		NULL;
	}
	return result;
}

//extern CString GetAppPath();
/*++
功能：向终端的存储空间写信息。
参数：
	lStartAddr:				要写的存储空间的开始地址。
	plDataLen:				输入为要写的数据的长度；输出为写入的实际长度。
	pData:					要写的数据。
--*/
HRESULT DVTSTBCA_WriteDataBuffer(const char * pStartAddr,long * plDataLen,const unsigned char* pData)
{
	HRESULT result = 0;
	if(*plDataLen<0)
		return -1;
	if((DWORD)pStartAddr < (DWORD)g_BufferForCAS
	|| (DWORD)pStartAddr >= (DWORD)g_BufferForCAS + FOR_CAS_DATA_BUFFER_SIZE)
	{
		return -1;
	}
	if((DWORD)pStartAddr + (*plDataLen) - (DWORD)g_BufferForCAS > FOR_CAS_DATA_BUFFER_SIZE)
	{
		*plDataLen = FOR_CAS_DATA_BUFFER_SIZE - ((DWORD)pStartAddr - (DWORD)g_BufferForCAS);
	}
	try
	{
		memcpy((void*)pStartAddr,pData,*plDataLen);
		FILE * cafile;
		char   capath[256];

		//sprintf(capath, "%s%s\\CaFile.data", ddbsdk.ddbsdk_path_main, DDBSDK_MAINPATH_NAME);
		if((cafile = fopen("\\Flash_Storage\\softcard.ca", "wb")) == NULL)
		{
			return -1;
		}
		fwrite(g_BufferForCAS, 1, FOR_CAS_DATA_BUFFER_SIZE, cafile);
		fclose(cafile);
	}
	catch(...)
	{
		NULL;
	}
	return result;
}

/*++
功能：CA程序用此函数设置解扰器。将当前周期及下一周期的CW送给解扰器。
参数：
	wEcmPID:				CW所属的ECMPID。
	szOddKey:				奇CW的数据。
	szEvenKey:				偶CW的数据。
	byKeyLen:				CW的长度。
--*/
HRESULT DVTSTBCA_SetDescrCW(WORD wEcmPID, BYTE byKeyLen, const unsigned char* szOddKey,const unsigned char* szEvenKey)
{
//	printf("设置解扰器\n");
//	memcpy(g_OddCW, szOddKey, byKeyLen);
//	memcpy(g_EvenCW, szEvenKey, byKeyLen);
//	g_bDDBHaveCW = 1;
	printf("设置解扰器==>   wEcmPID = %d\n",wEcmPID);
	if(wEcmPID == g_wTrafficEcmPid)
	{
		g_bTrafficHaveCW = true;
		memcpy(g_TrafficOddCW, szOddKey, byKeyLen);
		memcpy(g_TrafficEvenCW, szEvenKey, byKeyLen);
		//g_bWeatherHaveCW = false;
		//g_bFinanceHaveCW = false;
		//g_bPOIinfoHaveCW = false;
		//g_bSerFileHaveCW = false;
		return 0;
	}
	if(wEcmPID == g_wWeatherEcmPid)
	{
		g_bWeatherHaveCW = true;
		memcpy(g_WeatherOddCW, szOddKey, byKeyLen);
		memcpy(g_WeatherEvenCW, szEvenKey, byKeyLen);
		//g_bTrafficHaveCW = false;
		//g_bFinanceHaveCW = false;
		//g_bPOIinfoHaveCW = false;
		//g_bSerFileHaveCW = false;
		return 0;
	}
	if(wEcmPID == g_wFinanceEcmPid)
	{
		//printf("g_bFinanceHaveCW address = %x",&g_bFinanceHaveCW);
		g_bFinanceHaveCW = true;
		memcpy(g_FinanceOddCW, szOddKey, byKeyLen);
		memcpy(g_FinanceEvenCW, szEvenKey, byKeyLen);
		//g_bTrafficHaveCW = false;
		//g_bWeatherHaveCW = false;
		//g_bPOIinfoHaveCW = false;
		//g_bSerFileHaveCW = false;
		return 0;
	}
	if(wEcmPID == g_wPOIinfoEcmPid)
	{
		g_bPOIinfoHaveCW = true;
		memcpy(g_POIinfoOddCW, szOddKey, byKeyLen);
		memcpy(g_POIinfoEvenCW, szEvenKey, byKeyLen);
		//g_bTrafficHaveCW = false;
		//g_bWeatherHaveCW = false;
		//g_bFinanceHaveCW = false;
		//g_bSerFileHaveCW = false;
		return 0;
	}
	if(wEcmPID == g_wSerFileEcmPid)
	{
		//printf("g_bSerFileHaveCW address = %x\n",&g_bSerFileHaveCW);
		g_bSerFileHaveCW = true;
		memcpy(g_SerFileOddCW, szOddKey, byKeyLen);
		memcpy(g_SerFileEvenCW, szEvenKey, byKeyLen);
		//g_bTrafficHaveCW = false;
		//g_bWeatherHaveCW = false;
		//g_bFinanceHaveCW = false;
		//g_bPOIinfoHaveCW = false;
		return 0;
	}
	return 0;
	//解扰器可以用g_OddCW和g_EvenCW解扰业务数据，
	//如果TS加扰控制标志位是11用szOddKey，如果为10用szEvenKey
}

//显示提示信息
void  DVTSTBCA_ShowPromptMessage(BYTE byMesageNo)
{
	if(g_wCurrentEcmPid == g_wTrafficEcmPid)
	{
		g_bTrafficHaveCW = false;
	}
	else if(g_wCurrentEcmPid == g_wWeatherEcmPid)
	{
		g_bWeatherHaveCW = false;
	}else if(g_wCurrentEcmPid == g_wFinanceEcmPid)
	{
		g_bFinanceHaveCW = false;
	}else if(g_wCurrentEcmPid == g_wPOIinfoEcmPid)
	{
		g_bPOIinfoHaveCW = false;
	}else if(g_wCurrentEcmPid == g_wSerFileEcmPid)
	{
		g_bSerFileHaveCW = false;
	}

	char * str;
	switch(byMesageNo)
	{
	case DVTCA_TVS_NOT_FOUND:
		str = "the ISP key donnot exist!";
		break;
	case DVTCA_KEY_NOT_FOUND:
		str = "the ISP does not exist!";
		break;
	case DVTCA_DECRYPT_FAILURE:
		str = "encrypted program!";
		break;
	case DVTCA_NO_ENTITLE:
		str = "donnot buy this program!";
		break;
	case DVTCA_SC_IS_FORBIDDEN:
		str = "forbidden card!";
		break;
	case DVTCA_DATA_INVALID:
		str = "cannot receive program!";
		break;
	default:
		str = "unknown!";
		break;
	}
	//将str显示出来
	printf("%s\n", str);
}

/*++
功能：打印调试信息。
参数：
	pszMsg:					调试信息内容。
--*/
void DVTSTBCA_AddDebugMsg(const char *pszMsg)
{
	char * str = "ca module: ";
	//将调试信息显示出来
	//......
	printf("%s%s\n", str, pszMsg);
}

void DVTSTBCA_HidePromptMessage(void)
{
	//清除提示信息
}


